---
layout: post
title:  "GSoC 2019 | Week 1, 2"
date:   2019-06-10
---

During the first week of GSoC coding period, I worked on adding indexing support for arbitrary dimensional matrices. Till now, NMatrix only supported 2-dimensional matrices and the code assumed the NMatrix object to be of 2 dimensions. I first needed to modify code to store no. of dimensions and then write indexing conversions to map input comma separated indexes to the index of corresponding element in the flat list of elements stored at back-end. This was done pretty easily with the help of strides which were the prefixes for each comma separated index value in the equation to calculate required index in flat list. Once the indexing part was done and working, I wrote the setters and getters for matrix elements. I wrote some tests for indexing(setting and getting).

```
void get_stride(nmatrix* nmat, size_t* stride){
  size_t val = 1;
  for(int i = (nmat->ndims)-1; i >= 0; --i){ //using int here instead of size_t
    stride[i] = val;                         //because size_t does not support
    val *= nmat->shape[i];                    //decrement operator
  }
} 
```

```
size_t get_index(nmatrix* nmat, VALUE* indices){
  size_t index = 0;
  size_t* stride = (size_t*)calloc(nmat->ndims, sizeof(size_t));
  get_stride(nmat, stride);
  for(size_t i = 0; i < nmat->ndims; ++i){

    if((size_t)FIX2LONG(indices[i]) >= nmat->shape[i] ||
          (int)FIX2LONG(indices[i]) < 0) {  //index out of bounds
      rb_raise(rb_eIndexError, "IndexError: index is out of bounds.");
    }

    index += ((size_t)FIX2LONG(indices[i]) * stride[i]);
  }
  return index;
}
```

The second week of GSoC was spent in implementing iterators for NMatrix. `NMatrix#each` was easy to implement as it was simply yielding each element from the flat list of elements. It seemed to me that other iterators would also be as easy to implement but it wasn't so as it took quite a lot of time to implement iterators with indexes. Iterators with indexes yield both the current element and the associated comma separated indexes with it. For increment of comma separated indexes after each iteration, I wrote function `increment_index` which would increment current values to next one.

```
void increment_state(VALUE* state_array, VALUE* shape_array, size_t ndims) {

  for (size_t index = ndims; index > 0; index--) {
    int curr_dim_index = (int)NUM2INT(state_array[index]);
    int curr_dim_length = (int)NUM2INT(shape_array[index - 1]);

    if (curr_dim_index + 1 == curr_dim_length) {
      curr_dim_index = 0;
      state_array[index] = INT2NUM(curr_dim_index);
    } else {
      curr_dim_index++;
      state_array[index] = INT2NUM(curr_dim_index);
      break;
    }

  }
}
```

List of iterators implemented:

+	`NMatrix#each`
+	`NMatrix#each_with_indices`
+	`NMatrix#each_row`
+	`NMatrix#each_column`

Iterators yet to be implemented:

+	`NMatrix#each_layer`
+	`NMatrix#each_rank`
+	`NMatrix#each_stored_with_indices`
+	`NMatrix#each_ordered_stored_with_indices`
+	`NMatrix#map_stored`

For coming weeks, I'll complete the above remaining iterators and start work on slicing and broadcasting. Feel free to share your thoughts in the comments section. Thanks for reading.
